<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Cat Race - Enhanced</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .cat {
            transition: left 0.5s ease-in-out, transform 0.2s;
            width: 50px;
            height: 50px;
            text-align: center;
            line-height: 50px;
            font-size: 2rem;
            position: absolute;
            bottom: 10px;
            animation: bounceCat 0.7s infinite alternate ease-in-out;
        }
        @keyframes bounceCat {
            0% { transform: translateY(0); }
            100% { transform: translateY(-4px); }
        }
        .track-lane {
            height: 80px;
            border-bottom: 2px dashed #a5f3fc; /* Lighter cyan dash */
            position: relative;
            background-color: rgba(255, 255, 255, 0.1); /* Slight highlight for lanes */
            border-radius: 8px; /* Rounded lanes */
        }
        .finish-line {
            position: absolute;
            right: 15px; /* Adjusted for better visibility */
            top: -5px; /* Extend slightly above/below lanes */
            bottom: -5px;
            width: 12px;
            background-image: linear-gradient(45deg, #333 25%, transparent 25%), linear-gradient(-45deg, #333 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #333 75%), linear-gradient(-45deg, transparent 75%, #333 75%);
            background-size: 12px 12px;
            background-position: 0 0, 0 6px, 6px -6px, -6px 0px;
            border-left: 2px solid #111;
            border-right: 2px solid #111;
            z-index: 10;
        }
        .cat-name {
            font-size: 0.75rem;
            text-align: center;
            position: absolute;
            bottom: -22px;
            width: 100%;
            left: 0;
            font-weight: 500;
            color: #374151; /* Darker gray for better contrast on green track */
        }
        #messageModal, #loadingScreen {
            transition: opacity 0.3s ease-in-out;
        }
        /* General button styling */
        .btn {
            @apply font-semibold py-2 px-4 rounded-lg shadow-md transition-all duration-150 ease-in-out transform hover:scale-105 active:scale-95 disabled:opacity-60 disabled:cursor-not-allowed disabled:transform-none;
        }
        .btn-green { @apply bg-green-500 hover:bg-green-600 text-white; }
        .btn-red { @apply bg-red-500 hover:bg-red-600 text-white; }
        .btn-blue { @apply bg-blue-500 hover:bg-blue-600 text-white; }
        .btn-yellow { @apply bg-yellow-500 hover:bg-yellow-600 text-white; }
        .btn-purple { @apply bg-purple-500 hover:bg-purple-600 text-white; }
        .btn-indigo { @apply bg-indigo-500 hover:bg-indigo-600 text-white; }
        .btn-slate { @apply bg-slate-500 hover:bg-slate-600 text-white; }


    </style>
</head>
<body class="bg-gradient-to-br from-teal-400 to-cyan-600 min-h-screen flex flex-col items-center justify-center p-4 text-white">

    <div id="loadingScreen" class="fixed inset-0 bg-black bg-opacity-80 flex flex-col items-center justify-center z-50">
        <div class="text-5xl animate-spin">🐾</div>
        <p class="text-2xl mt-6 font-semibold">Loading Epic Cat Race...</p>
    </div>

    <div id="gameContainer" class="w-full max-w-4xl bg-white/95 backdrop-blur-lg shadow-2xl rounded-xl p-6 md:p-8 text-slate-800 hidden">

        <div id="setupScreen">
            <h1 class="text-3xl md:text-4xl font-bold text-center text-cyan-700 mb-8">Epic Cat Race! 🏁</h1>
            <div class="grid md:grid-cols-2 gap-6 mb-6">
                <div>
                    <label for="playerName" class="block text-sm font-medium text-slate-700 mb-1">Your Name:</label>
                    <input type="text" id="playerName" class="w-full p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-cyan-500 focus:border-cyan-500" placeholder="Captain Catnip">
                </div>
                <div>
                    <label for="catName" class="block text-sm font-medium text-slate-700 mb-1">Cat's Name:</label>
                    <input type="text" id="catName" class="w-full p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-cyan-500 focus:border-cyan-500" placeholder="Zoomer">
                </div>
            </div>
             <div class="mb-6">
                <label class="block text-sm font-medium text-slate-700 mb-1">Choose Your Champion:</label>
                <div class="flex items-center gap-3 bg-slate-100 p-2 rounded-lg">
                    <button id="prevCatEmojiBtn" class="btn bg-slate-200 hover:bg-slate-300 text-slate-700 px-3 py-2 text-xl">⬅️</button>
                    <span id="selectedCatEmojiDisplay" class="text-4xl w-12 h-12 flex items-center justify-center bg-white rounded-md shadow">🐱</span>
                    <button id="nextCatEmojiBtn" class="btn bg-slate-200 hover:bg-slate-300 text-slate-700 px-3 py-2 text-xl">➡️</button>
                </div>
            </div>
            <div class="text-sm text-slate-600 mb-6">Your User ID: <strong id="userIdDisplay" class="text-cyan-600">Initializing...</strong> (Share to race with specific friends)</div>

            <div class="mb-8 p-4 bg-cyan-50 rounded-lg border border-cyan-200">
                <h2 class="text-xl font-semibold text-cyan-700 mb-3">Create New Race</h2>
                <div class="flex flex-col sm:flex-row gap-3">
                    <input type="text" id="newGameName" class="flex-grow p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-cyan-500 focus:border-cyan-500" placeholder="e.g., Midnight Meow-athon">
                    <button id="createGameBtn" class="btn btn-green py-3 px-6">Create Race</button>
                </div>
            </div>

            <div class="p-4 bg-teal-50 rounded-lg border border-teal-200">
                <h2 class="text-xl font-semibold text-teal-700 mb-3">Join Existing Race</h2>
                <div id="gamesList" class="space-y-3 max-h-60 overflow-y-auto bg-white p-3 rounded-lg border border-slate-200 shadow-inner">
                    <p class="text-slate-500 p-2">No available races. Why not create one?</p>
                    </div>
            </div>
        </div>

        <div id="raceScreen" class="hidden">
            <div class="flex flex-col sm:flex-row justify-between items-center mb-4 gap-2">
                <h1 id="gameNameDisplay" class="text-2xl md:text-3xl font-bold text-cyan-700 truncate">Race in Progress...</h1>
                <button id="leaveGameBtn" class="btn btn-red py-2 px-4 self-end sm:self-center">Leave Race</button>
            </div>

            <div class="text-center mb-4">
                 <button id="startGameBtn" class="hidden btn btn-yellow py-3 px-8 text-lg">Start Race!</button>
            </div>

            <div id="raceTrack" class="w-full bg-green-300 p-4 rounded-lg shadow-inner border-2 border-green-400 relative mb-6 space-y-2 overflow-hidden">
                <div class="finish-line"></div>
                </div>
            <div id="raceMessages" class="mb-4 text-center text-lg font-semibold text-purple-700 min-h-[1.5em]"></div>

            <div class="text-center space-y-3">
                <button id="boostBtn" class="btn btn-blue font-bold py-4 px-10 rounded-full shadow-xl text-xl">
                    Boost My Cat! 🚀
                </button>
                <p id="boostCooldownText" class="text-sm text-slate-600 min-h-[1.2em]">&nbsp;</p>
                <button id="playAgainBtn" class="hidden btn btn-purple py-3 px-6">Play Again?</button>
            </div>
        </div>
        <p class="text-center text-xs text-slate-400 mt-8">© Mehboob</p>
    </div>

    <div id="messageModal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-[100] hidden opacity-0">
        <div class="bg-white p-6 rounded-xl shadow-2xl max-w-md w-full text-slate-800 transform transition-all scale-95">
            <h3 id="modalTitle" class="text-2xl font-bold mb-4 text-cyan-700">Notification</h3>
            <p id="modalMessage" class="mb-6 text-slate-600 text-base">This is a message.</p>
            <button id="modalCloseBtn" class="w-full btn btn-indigo py-2.5">
                OK
            </button>
        </div>
    </div>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, query, where, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Configuration & Global Variables ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : { apiKey: "YOUR_API_KEY", authDomain: "YOUR_AUTH_DOMAIN", projectId: "YOUR_PROJECT_ID" };
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'cat-race-default-app-id';

        let app;
        let auth;
        let db;
        let currentUserId = null;
        let currentGameId = null;
        let unsubscribeGameListener = null;
        let unsubscribeGamesListListener = null;
        let boostCooldownTimeout = null;

        const BOOST_COOLDOWN = 3000; // 3 seconds
        const CAT_EMOJIS = ['🐱', '😺', '😸', '😹', '😻', '😼', '😽', '🙀', '😿', '😾', '🐈', '🦁', '🐅', '🐆'];
        let currentEmojiIndex = 0;
        let selectedCatEmoji = CAT_EMOJIS[currentEmojiIndex];
        const MAX_PLAYERS = 4;


        // --- UI Elements ---
        const loadingScreen = document.getElementById('loadingScreen');
        const gameContainer = document.getElementById('gameContainer');
        const setupScreen = document.getElementById('setupScreen');
        const raceScreen = document.getElementById('raceScreen');
        const playerNameInput = document.getElementById('playerName');
        const catNameInput = document.getElementById('catName');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const newGameNameInput = document.getElementById('newGameName');
        const createGameBtn = document.getElementById('createGameBtn');
        const gamesListDiv = document.getElementById('gamesList');
        const gameNameDisplay = document.getElementById('gameNameDisplay');
        const raceTrackDiv = document.getElementById('raceTrack');
        const boostBtn = document.getElementById('boostBtn');
        const boostCooldownText = document.getElementById('boostCooldownText');
        const leaveGameBtn = document.getElementById('leaveGameBtn');
        const raceMessages = document.getElementById('raceMessages');
        const prevCatEmojiBtn = document.getElementById('prevCatEmojiBtn');
        const selectedCatEmojiDisplay = document.getElementById('selectedCatEmojiDisplay');
        const nextCatEmojiBtn = document.getElementById('nextCatEmojiBtn');
        const startGameBtn = document.getElementById('startGameBtn');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const messageModal = document.getElementById('messageModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalCloseBtn = document.getElementById('modalCloseBtn');

        // --- Utility Functions ---
        function showModal(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            messageModal.classList.remove('hidden');
            setTimeout(() => {
                messageModal.classList.remove('opacity-0');
                messageModal.querySelector('div').classList.remove('scale-95');
            }, 10);
        }

        modalCloseBtn.addEventListener('click', () => {
            messageModal.classList.add('opacity-0');
            messageModal.querySelector('div').classList.add('scale-95');
            setTimeout(() => messageModal.classList.add('hidden'), 300);
        });

        function updateSelectedCatEmojiDisplay() {
            selectedCatEmoji = CAT_EMOJIS[currentEmojiIndex];
            selectedCatEmojiDisplay.textContent = selectedCatEmoji;
        }

        // --- Firebase Initialization and Auth ---
        async function initializeFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                // import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"; // For debugging
                // setLogLevel('debug');

                await setPersistence(auth, browserLocalPersistence);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        userIdDisplay.textContent = currentUserId;
                        console.log("User authenticated with UID:", currentUserId);
                        loadInitialData();
                        showScreen('setup');
                    } else {
                        console.log("User not signed in, attempting auth.");
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await signInWithCustomToken(auth, __initial_auth_token);
                        } else {
                            await signInAnonymously(auth);
                        }
                    }
                    loadingScreen.classList.add('opacity-0');
                    setTimeout(() => loadingScreen.classList.add('hidden'), 300);
                    gameContainer.classList.remove('hidden');
                });
            } catch (error) {
                console.error("Firebase initialization error:", error);
                showModal("Initialization Error", "Could not initialize the game. Please try again. Details: " + error.message);
                loadingScreen.innerHTML = `<p class="text-red-500 text-xl p-4">Error loading game: ${error.message}</p>`;
            }
        }

        // --- Screen Management ---
        function showScreen(screenName) {
            setupScreen.classList.add('hidden');
            raceScreen.classList.add('hidden');
            if (screenName === 'setup') {
                setupScreen.classList.remove('hidden');
            } else if (screenName === 'race') {
                raceScreen.classList.remove('hidden');
            }
        }

        // --- Game Logic ---
        function getGamesCollectionRef() {
            return collection(db, `artifacts/${appId}/public/data/catRaces`);
        }

        function getGameDocRef(gameId) {
            return doc(db, `artifacts/${appId}/public/data/catRaces`, gameId);
        }

        async function createGame() {
            if (!currentUserId) {
                showModal("Authentication Error", "You must be signed in to create a game.");
                return;
            }
            const pName = playerNameInput.value.trim() || "Player " + currentUserId.substring(0,4);
            const cName = catNameInput.value.trim() || "Cat " + currentUserId.substring(0,4);
            const gameName = newGameNameInput.value.trim();

            if (!gameName) { showModal("Input Required", "Please enter a name for your race."); return; }
            if (!pName || !cName) { showModal("Input Required", "Please enter your name and your cat's name."); return; }

            createGameBtn.disabled = true;
            createGameBtn.textContent = "Creating...";

            try {
                const newGameRef = doc(getGamesCollectionRef()); // Auto-generate ID
                const initialPlayer = {
                    id: currentUserId,
                    name: pName,
                    catName: cName,
                    catEmoji: selectedCatEmoji,
                    position: 0,
                    lastBoostTime: null
                };
                await setDoc(newGameRef, {
                    name: gameName,
                    creatorId: currentUserId,
                    status: "waiting", // waiting, in-progress, finished
                    winner: null,
                    createdAt: serverTimestamp(),
                    players: { [currentUserId]: initialPlayer },
                    originalPlayerIds: [currentUserId], // For play again logic
                    trackLength: 100
                });
                console.log("Game created with ID:", newGameRef.id);
                joinGame(newGameRef.id); // Auto-join after creation
            } catch (error) {
                console.error("Error creating game:", error);
                showModal("Creation Error", "Could not create race. " + error.message);
            } finally {
                createGameBtn.disabled = false;
                createGameBtn.textContent = "Create Race";
            }
        }

        async function joinGame(gameId) {
            if (!currentUserId) { showModal("Authentication Error", "You must be signed in to join a game."); return; }
            if (currentGameId && currentGameId !== gameId) { await leaveCurrentGame(); }

            const pName = playerNameInput.value.trim() || "Player " + currentUserId.substring(0,4);
            const cName = catNameInput.value.trim() || "Cat " + currentUserId.substring(0,4);
            if (!pName || !cName) { showModal("Input Required", "Please enter your name and cat's name before joining."); return; }

            currentGameId = gameId;
            console.log(`Attempting to join/spectate game: ${gameId} as user: ${currentUserId}`);

            try {
                const gameRef = getGameDocRef(gameId);
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef);
                    if (!gameDoc.exists()) throw new Error("Race not found!");
                    
                    const gameData = gameDoc.data();

                    if (gameData.status === "finished") throw new Error("This race has already finished!");

                    if (!gameData.players[currentUserId]) { // If user is not already in the players list
                        if (gameData.status === "in-progress") {
                            // Allow joining as spectator, no changes to Firestore needed for this type of spectator
                            console.log(`User ${currentUserId} is spectating game ${gameId}`);
                        } else if (gameData.status === "waiting") {
                            if (Object.keys(gameData.players).length >= MAX_PLAYERS) {
                                throw new Error(`Race is full! Max ${MAX_PLAYERS} players.`);
                            }
                            const newPlayer = {
                                id: currentUserId, name: pName, catName: cName,
                                catEmoji: selectedCatEmoji, position: 0, lastBoostTime: null
                            };
                            const updatedOriginalPlayerIds = Array.from(new Set([...(gameData.originalPlayerIds || []), currentUserId]));
                            transaction.update(gameRef, {
                                [`players.${currentUserId}`]: newPlayer,
                                originalPlayerIds: updatedOriginalPlayerIds
                            });
                        }
                    } else {
                        console.log(`User ${currentUserId} is rejoining game ${gameId}`);
                    }
                });

                showScreen('race');
                listenToGameUpdates(gameId);

            } catch (error) {
                console.error("Error joining game:", error);
                showModal("Join Error", error.message);
                currentGameId = null; // Reset if join failed
            }
        }
        
        function listenToGameUpdates(gameId) {
            if (unsubscribeGameListener) unsubscribeGameListener();
            
            const gameRef = getGameDocRef(gameId);
            unsubscribeGameListener = onSnapshot(gameRef, (docSnapshot) => {
                if (!docSnapshot.exists()) {
                    showModal("Race Ended", "The race you were in no longer exists.");
                    showScreen('setup');
                    resetRaceState();
                    return;
                }
                const gameData = docSnapshot.data();
                gameNameDisplay.textContent = gameData.name;
                updateRaceTrack(gameData.players, gameData.trackLength);

                const myPlayerData = gameData.players[currentUserId];
                const isSpectator = !myPlayerData && gameData.status === "in-progress";

                // Reset buttons visibility first
                startGameBtn.classList.add('hidden');
                playAgainBtn.classList.add('hidden');
                boostBtn.disabled = true; // Disable by default, enable if conditions met

                if (isSpectator) {
                    raceMessages.textContent = "You are spectating 👀";
                    boostCooldownText.textContent = "Spectators can't boost.";
                } else if (gameData.status === "finished" && gameData.winner) {
                    const winnerPlayer = gameData.players[gameData.winner];
                    raceMessages.textContent = winnerPlayer ? `${winnerPlayer.catName} (${winnerPlayer.name}) wins! 🏆` : "Race Finished!";
                    boostCooldownText.textContent = "Race Over!";
                    if (myPlayerData && gameData.creatorId === currentUserId) { // Only creator sees play again for now
                         playAgainBtn.classList.remove('hidden');
                    }
                } else if (gameData.status === "in-progress") {
                    raceMessages.textContent = "Race is ON! Go go go!";
                    if (myPlayerData) { // Player is in the game
                        const now = Date.now();
                        if (myPlayerData.lastBoostTime && (now - myPlayerData.lastBoostTime < BOOST_COOLDOWN)) {
                            setBoostCooldownUI(myPlayerData.lastBoostTime, gameData); // Pass gameData
                        } else {
                            boostBtn.disabled = false;
                            boostCooldownText.textContent = "Boost Ready!";
                        }
                    } else { // Should not happen if not spectator, but as a safe guard
                        boostCooldownText.textContent = "Can't boost now.";
                    }
                } else if (gameData.status === "waiting") {
                    raceMessages.textContent = `Waiting for players... (${Object.keys(gameData.players).length}/${MAX_PLAYERS})`;
                    boostCooldownText.textContent = "Race hasn't started.";
                    if (gameData.creatorId === currentUserId) {
                        startGameBtn.classList.remove('hidden');
                    }
                }

            }, (error) => {
                console.error("Error listening to game updates:", error);
                showModal("Connection Issue", "Lost connection to the race. " + error.message);
            });
        }

        function updateRaceTrack(playersData, trackLength) {
            raceTrackDiv.innerHTML = '<div class="finish-line"></div>'; // Clear previous cats
            const playersArray = Object.values(playersData || {});
            playersArray.sort((a, b) => a.id.localeCompare(b.id)); // Consistent lane order

            playersArray.forEach((player) => {
                const laneDiv = document.createElement('div');
                laneDiv.className = 'track-lane';

                const catDiv = document.createElement('div');
                catDiv.className = 'cat';
                catDiv.textContent = player.catEmoji || '🐾';
                if (player.id === currentUserId) {
                    catDiv.classList.add('border-2', 'border-yellow-400', 'rounded-full', 'shadow-lg'); // Highlight current player's cat
                }
                const progressPercent = Math.min(player.position / trackLength, 1);
                catDiv.style.left = `calc(${progressPercent * 100}% - ${progressPercent * 50}px)`;

                const catNameSpan = document.createElement('div');
                catNameSpan.className = 'cat-name';
                catNameSpan.textContent = `${player.catName} (${player.name})`;
                
                catDiv.appendChild(catNameSpan);
                laneDiv.appendChild(catDiv);
                raceTrackDiv.appendChild(laneDiv);
            });
        }

        async function boostCat() {
            if (!currentUserId || !currentGameId) return;
            
            const gameRef = getGameDocRef(currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef);
                    if (!gameDoc.exists()) throw new Error("Race not found.");
                    
                    const gameData = gameDoc.data();
                    const player = gameData.players[currentUserId];

                    if (!player) throw new Error("You are not an active racer in this game.");
                    if (gameData.status !== "in-progress") throw new Error("Race is not currently active.");
                    if (gameData.winner) throw new Error("Race has already finished!");

                    const now = Date.now();
                    if (player.lastBoostTime && (now - player.lastBoostTime < BOOST_COOLDOWN)) {
                        throw new Error("Boost is still on cooldown!");
                    }

                    const boostAmount = Math.floor(Math.random() * 12) + 6; // Boost 6-17
                    let newPosition = player.position + boostAmount;
                    const updates = {
                        [`players.${currentUserId}.lastBoostTime`]: now,
                        [`players.${currentUserId}.position`]: newPosition
                    };

                    if (newPosition >= gameData.trackLength && !gameData.winner) {
                        updates[`players.${currentUserId}.position`] = gameData.trackLength;
                        updates.winner = currentUserId;
                        updates.status = "finished";
                    }
                    transaction.update(gameRef, updates);
                });
                // setBoostCooldownUI will be called by the snapshot listener reacting to lastBoostTime update
            } catch (error) {
                console.error("Error boosting cat:", error);
                showModal("Boost Error", error.message); // Show specific error from transaction
                // Re-enable boost button only if error was not cooldown related and game still allows boosting
                const gameDoc = await getDoc(gameRef);
                if (gameDoc.exists()) {
                    const gameData = gameDoc.data();
                    const myPlayerData = gameData.players[currentUserId];
                    if (myPlayerData && gameData.status === 'in-progress' && !gameData.winner && !(myPlayerData.lastBoostTime && (Date.now() - myPlayerData.lastBoostTime < BOOST_COOLDOWN))) {
                        boostBtn.disabled = false;
                    }
                }
            }
        }

        function setBoostCooldownUI(lastBoostTime, gameData) { // Pass gameData
            boostBtn.disabled = true;
            if (boostCooldownTimeout) clearTimeout(boostCooldownTimeout);

            const updateText = () => {
                if (!gameData || !currentGameId) { // Game ended or left
                    clearTimeout(boostCooldownTimeout);
                    return;
                }
                const timeSinceLastBoost = Date.now() - lastBoostTime;
                const timeLeft = BOOST_COOLDOWN - timeSinceLastBoost;

                // Fetch fresh game data for status check inside timeout, or rely on passed gameData
                const currentStatus = gameData.status; 
                const currentWinner = gameData.winner;

                if (timeLeft <= 0) {
                    boostCooldownText.textContent = "Boost Ready!";
                    if (currentStatus === "in-progress" && !currentWinner && gameData.players[currentUserId]) {
                       boostBtn.disabled = false;
                    } else {
                       if(currentWinner) boostCooldownText.textContent = "Race Over!";
                       else if (currentStatus !== "in-progress") boostCooldownText.textContent = "Race not active.";
                    }
                    clearTimeout(boostCooldownTimeout);
                } else {
                    boostCooldownText.textContent = `Boost in ${(timeLeft / 1000).toFixed(1)}s`;
                    boostCooldownTimeout = setTimeout(updateText, 100);
                }
            };
            updateText();
        }

        async function leaveCurrentGame() {
            if (!currentUserId || !currentGameId) return;
            console.log(`Player ${currentUserId} leaving game ${currentGameId}`);
            if (unsubscribeGameListener) { unsubscribeGameListener(); unsubscribeGameListener = null; }

            try {
                const gameRef = getGameDocRef(currentGameId);
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef);
                    if (gameDoc.exists()) {
                        const gameData = gameDoc.data();
                        const updatedPlayers = { ...gameData.players };
                        delete updatedPlayers[currentUserId];
                        
                        const updatedOriginalPlayerIds = (gameData.originalPlayerIds || []).filter(id => id !== currentUserId);

                        if (Object.keys(updatedPlayers).length === 0) {
                            transaction.delete(gameRef);
                            console.log(`Game ${currentGameId} deleted.`);
                        } else {
                            let newCreatorId = gameData.creatorId;
                            if (gameData.creatorId === currentUserId && updatedOriginalPlayerIds.length > 0) {
                                // If creator leaves, assign a new creator from original players if possible
                                newCreatorId = updatedOriginalPlayerIds[0]; 
                                console.log(`New creator assigned: ${newCreatorId}`);
                            } else if (updatedOriginalPlayerIds.length === 0) {
                                // If no original players left (e.g. only creator was there), effectively no creator
                                newCreatorId = null;
                            }

                            transaction.update(gameRef, { 
                                players: updatedPlayers,
                                originalPlayerIds: updatedOriginalPlayerIds,
                                creatorId: newCreatorId 
                            });
                        }
                    }
                });
            } catch (error) {
                console.error("Error leaving game:", error);
            } finally {
                resetRaceState();
            }
        }
        
        async function startGameHandler() {
            if (!currentUserId || !currentGameId) return;
            const gameRef = getGameDocRef(currentGameId);
            try {
                const gameDoc = await getDoc(gameRef);
                if (gameDoc.exists() && gameDoc.data().creatorId === currentUserId && gameDoc.data().status === "waiting") {
                    await updateDoc(gameRef, { status: "in-progress" });
                    raceMessages.textContent = "Race Started by Creator!";
                    startGameBtn.classList.add('hidden');
                } else {
                    showModal("Start Error", "Only the creator can start a waiting game.");
                }
            } catch (error) {
                console.error("Error starting game:", error);
                showModal("Error", "Could not start race. " + error.message);
            }
        }

        async function playAgainHandler() {
            if (!currentUserId || !currentGameId) return;
            playAgainBtn.disabled = true;
            playAgainBtn.textContent = "Resetting...";

            try {
                const gameRef = getGameDocRef(currentGameId);
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameRef);
                    if (!gameDoc.exists()) throw new Error("Race not found.");
                    const gameData = gameDoc.data();

                    if (gameData.creatorId !== currentUserId) {
                        throw new Error("Only the original game creator can initiate a 'Play Again'.");
                    }
                    if (gameData.status !== "finished") {
                        throw new Error("Can only restart a finished game.");
                    }

                    const newPlayersData = {};
                    // Reset only original players who are still in the 'players' map (or all original if desired)
                    (gameData.originalPlayerIds || []).forEach(pid => {
                        if (gameData.players[pid]) { // Ensure player still exists in current game players map
                             newPlayersData[pid] = {
                                ...gameData.players[pid], // Keep name, emoji etc.
                                position: 0,
                                lastBoostTime: null,
                            };
                        } else { // If an original player left, re-add them with default names if needed
                            // Or, only include original players who are *still* in the gameData.players list.
                            // For simplicity, let's assume originalPlayerIds are the ones to reset.
                            // If they had left, their data might be stale.
                            // Better: only reset players currently in gameData.players who were also in originalPlayerIds
                             newPlayersData[pid] = { // Fallback if player data was lost somehow
                                id: pid, name: "Player " + pid.substring(0,4), catName: "Cat " + pid.substring(0,4),
                                catEmoji: CAT_EMOJIS[Math.floor(Math.random() * CAT_EMOJIS.length)],
                                position: 0, lastBoostTime: null
                            };
                        }
                    });
                     if (Object.keys(newPlayersData).length === 0 && gameData.originalPlayerIds.length > 0) {
                        // This case might happen if all original players left and then creator tried to restart
                        // For simplicity, we'll just ensure the creator is re-added if they were an original player
                        if (gameData.originalPlayerIds.includes(currentUserId) && !newPlayersData[currentUserId]) {
                             newPlayersData[currentUserId] = {
                                id: currentUserId, name: playerNameInput.value || "Player " + currentUserId.substring(0,4), 
                                catName: catNameInput.value || "Cat " + currentUserId.substring(0,4),
                                catEmoji: selectedCatEmoji, position: 0, lastBoostTime: null
                            };
                        }
                    }


                    transaction.update(gameRef, {
                        status: "waiting",
                        winner: null,
                        players: newPlayersData,
                        // creatorId remains the same
                        // originalPlayerIds remain the same for the next "play again"
                    });
                });
                raceMessages.textContent = "New race ready! Waiting for creator to start.";
            } catch (error) {
                console.error("Error during Play Again:", error);
                showModal("Play Again Error", error.message);
            } finally {
                 playAgainBtn.disabled = false;
                 playAgainBtn.textContent = "Play Again?";
            }
        }


        function resetRaceState() {
            currentGameId = null;
            raceTrackDiv.innerHTML = '<div class="finish-line"></div>';
            gameNameDisplay.textContent = "Race";
            boostBtn.disabled = true;
            boostCooldownText.textContent = "";
            raceMessages.textContent = "";
            startGameBtn.classList.add('hidden');
            playAgainBtn.classList.add('hidden');
            if (boostCooldownTimeout) clearTimeout(boostCooldownTimeout);
        }

        function loadInitialData() {
            if (!currentUserId) return;
            listenToAvailableGames();
            playerNameInput.value = localStorage.getItem('catRacePlayerName') || '';
            catNameInput.value = localStorage.getItem('catRaceCatName') || '';
            const storedEmojiIndex = parseInt(localStorage.getItem('catRaceEmojiIndex') || '0');
            currentEmojiIndex = (storedEmojiIndex >= 0 && storedEmojiIndex < CAT_EMOJIS.length) ? storedEmojiIndex : 0;
            updateSelectedCatEmojiDisplay();
        }

        function listenToAvailableGames() {
            if (unsubscribeGamesListListener) unsubscribeGamesListListener();
            
            const gamesQuery = query(getGamesCollectionRef()); // Listen to all games to show status correctly
            unsubscribeGamesListListener = onSnapshot(gamesQuery, (querySnapshot) => {
                gamesListDiv.innerHTML = '';
                if (querySnapshot.empty) {
                    gamesListDiv.innerHTML = '<p class="text-slate-500 p-2">No races found. Create one to start the fun!</p>';
                    return;
                }
                querySnapshot.forEach((doc) => {
                    const game = doc.data();
                    const gameId = doc.id;
                    const playerCount = Object.keys(game.players || {}).length;

                    const gameEntry = document.createElement('div');
                    gameEntry.className = 'p-3 bg-white hover:bg-cyan-50 rounded-lg shadow-sm border border-slate-200 flex justify-between items-center gap-2';

                    const gameInfo = document.createElement('div');
                    gameInfo.innerHTML = `
                        <span class="font-semibold text-cyan-800">${game.name}</span>
                        <span class="text-sm text-slate-600 ml-2">(${playerCount} player${playerCount === 1 ? '' : 's'})</span>
                        <span class="text-xs text-gray-500 ml-2 font-medium">[${game.status.toUpperCase()}]</span>
                    `;
                    gameEntry.appendChild(gameInfo);

                    const joinBtn = document.createElement('button');
                    joinBtn.className = 'btn text-sm py-1 px-3';

                    if (game.status === "waiting") {
                        if (playerCount >= MAX_PLAYERS) {
                            joinBtn.textContent = "Full";
                            joinBtn.disabled = true;
                            joinBtn.classList.add('btn-slate', 'opacity-50');
                        } else {
                            joinBtn.textContent = "Join";
                            joinBtn.classList.add('btn-green');
                        }
                    } else if (game.status === "in-progress") {
                        joinBtn.textContent = game.players[currentUserId] ? "Re-Join" : "Spectate";
                        joinBtn.classList.add('btn-yellow');
                    } else { // Finished
                        joinBtn.textContent = "Finished";
                        joinBtn.disabled = true;
                        joinBtn.classList.add('btn-slate', 'opacity-50');
                    }
                    
                    if (!joinBtn.disabled) {
                        joinBtn.onclick = () => {
                            if (playerNameInput.value.trim() && catNameInput.value.trim()){
                                joinGame(gameId);
                            } else {
                                showModal("Name Required", "Please set your name and cat's name first!");
                            }
                        };
                    }
                    gameEntry.appendChild(joinBtn);
                    gamesListDiv.appendChild(gameEntry);
                });
            }, (error) => {
                console.error("Error fetching games list:", error);
                gamesListDiv.innerHTML = '<p class="text-red-500 p-2">Error loading races. Please refresh.</p>';
            });
        }

        // --- Event Listeners ---
        createGameBtn.addEventListener('click', createGame);
        boostBtn.addEventListener('click', boostCat);
        leaveGameBtn.addEventListener('click', async () => { await leaveCurrentGame(); showScreen('setup'); });
        startGameBtn.addEventListener('click', startGameHandler);
        playAgainBtn.addEventListener('click', playAgainHandler);

        prevCatEmojiBtn.addEventListener('click', () => {
            currentEmojiIndex = (currentEmojiIndex - 1 + CAT_EMOJIS.length) % CAT_EMOJIS.length;
            updateSelectedCatEmojiDisplay();
            localStorage.setItem('catRaceEmojiIndex', currentEmojiIndex.toString());
        });
        nextCatEmojiBtn.addEventListener('click', () => {
            currentEmojiIndex = (currentEmojiIndex + 1) % CAT_EMOJIS.length;
            updateSelectedCatEmojiDisplay();
            localStorage.setItem('catRaceEmojiIndex', currentEmojiIndex.toString());
        });

        playerNameInput.addEventListener('change', () => localStorage.setItem('catRacePlayerName', playerNameInput.value));
        catNameInput.addEventListener('change', () => localStorage.setItem('catRaceCatName', catNameInput.value));

        // --- Start Application ---
        initializeFirebase().then(() => {
            // Optional: Start ambient movement if desired, after Firebase is ready
            // setTimeout(ambientCatMovement, 7000); // Disabled by default
        });
        
        // Note: ambientCatMovement function was removed for this version to simplify and focus on new features.
        // It can be added back if desired, similar to previous versions.

        window.addEventListener('beforeunload', async (event) => {
            // Firestore typically handles disconnections well with presence if implemented.
            // Forcing a leave here can be unreliable.
            // Consider it a "best effort" or rely on game cleanup for inactive players.
            if (currentGameId && currentUserId) {
                console.log("Page unloading, attempting to clean up game state if necessary.");
                // await leaveCurrentGame(); // This might not complete fully or reliably.
            }
        });

    </script>
</body>
</html>
